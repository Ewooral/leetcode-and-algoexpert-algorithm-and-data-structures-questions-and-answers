LEETCODE 75 QUESTIONS
QUE 39. COMBINATION SUM
Given an array of distinct integers candidates and a target integer target, return a list of
all unique combinations of candidates where the chosen numbers sum to target. You may return
the combinations in any order.

The same number may be chosen from candidates an unlimited number of times.
Two combinations are unique if the frequency of at least one of the chosen numbers is different.

It is guaranteed that the number of unique combinations that sum up to target is
less than 150 combinations for the given input.

Example 1:

Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.

Example 2:

Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]

Example 3:

Input: candidates = [2], target = 1
Output: []



Constraints:

    1 <= candidates.length <= 30
    1 <= candidates[i] <= 200
    All elements of candidates are distinct.
    1 <= target <= 500












3. LONGEST SUBSTRING WITHOUT REPEATING CHARACTERS
Medium

Given a string s, find the length of the longest substring without repeating characters.

Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.

Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.

Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.



Constraints:

    0 <= s.length <= 5 * 104
    s consists of English letters, digits, symbols and spaces.
















20. Valid Parentheses
Easy

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

    Open brackets must be closed by the same type of brackets.
    Open brackets must be closed in the correct order.



Example 1:

Input: s = "()"
Output: true

Example 2:

Input: s = "()[]{}"
Output: true

Example 3:

Input: s = "(]"
Output: false



Constraints:

    1 <= s.length <= 104
    s consists of parentheses only '()[]{}'.













5. Longest Palindromic Substring
Medium

Given a string s, return the longest palindromic substring in s.

Example 1:

Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.

Example 2:

Input: s = "cbbd"
Output: "bb"



Constraints:

    1 <= s.length <= 1000
    s consist of only digits and English letters.


















PATTERNS
SLIDING WINDOW


904. Fruit Into Baskets
Medium

You are visiting a farm that has a single row of fruit trees arranged from left to right.
The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:

    You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.
    Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.
    Once you reach a tree with fruit that cannot fit in your baskets, you must stop.

Given the integer array fruits, return the maximum number of fruits you can pick.



Example 1:

Input: fruits = [1,2,1]
Output: 3
Explanation: We can pick from all 3 trees.

Example 2:

Input: fruits = [0,1,2,2]
Output: 3
Explanation: We can pick from trees [1,2,2].
If we had started at the first tree, we would only pick from trees [0,1].

Example 3:

Input: fruits = [1,2,3,2,2]
Output: 4
Explanation: We can pick from trees [2,3,2,2].
If we had started at the first tree, we would only pick from trees [1,2].



Constraints:

    1 <= fruits.length <= 105
    0 <= fruits[i] < fruits.length


















995. Minimum Number of K Consecutive Bit Flips
Hard

You are given a binary array nums and an integer k.

A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.

Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.

A subarray is a contiguous part of an array.



Example 1:

Input: nums = [0,1,0], k = 1
Output: 2
Explanation: Flip nums[0], then flip nums[2].

Example 2:

Input: nums = [1,1,0], k = 2
Output: -1
Explanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].

Example 3:

Input: nums = [0,0,0,1,0,1,1,0], k = 3
Output: 3
Explanation:
Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]
Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]
Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]



Constraints:

    1 <= nums.length <= 105
    1 <= k <= nums.length

















828. Count Unique Characters of All Substrings of a Given String
Hard

Let's define a function countUniqueChars(s) that returns the number of unique characters on s.

    For example, calling countUniqueChars(s) if s = "LEETCODE" then "L", "T", "C", "O", "D" are the unique characters since they appear only once in s, therefore countUniqueChars(s) = 5.

Given a string s, return the sum of countUniqueChars(t) where t is a substring of s. The test cases are generated such that the answer fits in a 32-bit integer.

Notice that some substrings can be repeated so in this case you have to count the repeated ones too.



Example 1:

Input: s = "ABC"
Output: 10
Explanation: All possible substrings are: "A","B","C","AB","BC" and "ABC".
Every substring is composed with only unique letters.
Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10

Example 2:

Input: s = "ABA"
Output: 8
Explanation: The same as example 1, except countUniqueChars("ABA") = 1.

Example 3:

Input: s = "LEETCODE"
Output: 92



Constraints:

    1 <= s.length <= 105
    s consists of uppercase English letters only.














567. Permutation in String
Medium

Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.

In other words, return true if one of s1's permutations is the substring of s2.



Example 1:

Input: s1 = "ab", s2 = "eidbaooo"
Output: true
Explanation: s2 contains one permutation of s1 ("ba").

Example 2:

Input: s1 = "ab", s2 = "eidboaoo"
Output: false



Constraints:

    1 <= s1.length, s2.length <= 104
    s1 and s2 consist of lowercase English letters.




















424. Longest Repeating Character Replacement
Medium

You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.



Example 1:

Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.

Example 2:

Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.



Constraints:

    1 <= s.length <= 105
    s consists of only uppercase English letters.
    0 <= k <= s.length














239. Sliding Window Maximum
Hard

You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

Return the max sliding window.



Example 1:

Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation:
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

Example 2:

Input: nums = [1], k = 1
Output: [1]



Constraints:

    1 <= nums.length <= 105
    -104 <= nums[i] <= 104
    1 <= k <= nums.length

















Find the longest substring with k unique characters in a given string

    Difficulty Level : Hard
    Last Updated : 12 Dec, 2021

Given a string you need to print longest possible substring that has exactly M unique characters.
If there are more than one substring of longest possible length, then print any one of them.

Examples:

"aabbcc", k = 1
Max substring can be any one from {"aa" , "bb" , "cc"}.

"aabbcc", k = 2
Max substring can be any one from {"aabb" , "bbcc"}.

"aabbcc", k = 3
There are substrings with exactly 3 unique characters
{"aabbcc" , "abbcc" , "aabbc" , "abbc" }
Max is "aabbcc" with length 6.

"aaabbb", k = 3
There are only two unique characters, thus show error message.

















209. Minimum Size Subarray Sum
Medium

Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.



Example 1:

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.

Example 2:

Input: target = 4, nums = [1,4,4]
Output: 1

Example 3:

Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0



Constraints:

    1 <= target <= 109
    1 <= nums.length <= 105
    1 <= nums[i] <= 104


Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).
















76. Minimum Window Substring
Hard

Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".

The testcases will be generated such that the answer is unique.

A substring is a contiguous sequence of characters within the string.



Example 1:

Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.

Example 2:

Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.

Example 3:

Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.



Constraints:

    m == s.length
    n == t.length
    1 <= m, n <= 105
    s and t consist of uppercase and lowercase English letters.


Follow up: Could you find an algorithm that runs in O(m + n) time?









30. Substring with Concatenation of All Words (solved)
Hard

3. Longest Substring Without Repeating Characters (solved)
Medium


















FAST AND SLOW POINTERS


2. Add Two Numbers
Medium

You are given two non-empty linked lists representing two non-negative integers.
The digits are stored in reverse order, and each of their nodes contains a single digit.
Add the two numbers and return the sum as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example 1:

Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.

Example 2:

Input: l1 = [0], l2 = [0]
Output: [0]

Example 3:

Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]

Constraints:

    The number of nodes in each linked list is in the range [1, 100].
    0 <= Node.val <= 9
    It is guaranteed that the list represents a number that does not have leading zeros.


def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        dummyHead = ListNode(0)
        curr = dummyHead
        carry = 0
        while l1 != None or l2 != None or carry != 0:
            l1Val = l1.val if l1 else 0
            l2Val = l2.val if l2 else 0
            columnSum = l1Val + l2Val + carry
            carry = columnSum // 10
            newNode = ListNode(columnSum % 10)
            curr.next = newNode
            curr = newNode
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        return dummyHead.next



Algorithm

Just like how you would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of l1l1l1 and l2l2l2. Since each digit is in the range of 0…90 \ldots 90…9, summing two digits may "overflow". For example 5+7=125 + 7 = 125+7=12. In this case, we set the current digit to 222 and bring over the carry=1carry = 1carry=1 to the next iteration. carrycarrycarry must be either 000 or 111 because the largest possible sum of two digits (including the carry) is 9+9+1=199 + 9 + 1 = 199+9+1=19.

The pseudocode is as following:

    Initialize current node to dummy head of the returning list.
    Initialize carry to 000.
    Loop through lists l1l1l1 and l2l2l2 until you reach both ends and crarry is 000.
        Set xxx to node l1l1l1's value. If l1l1l1 has reached the end of l1l1l1, set to 000.
        Set yyy to node l2l2l2's value. If l2l2l2 has reached the end of l2l2l2, set to 000.
        Set sum=x+y+carrysum = x + y + carrysum=x+y+carry.
        Update carry=sum/10carry = sum / 10carry=sum/10.
        Create a new node with the digit value of (sum mod 10)(sum \bmod 10)(summod10) and set it to current node's next, then advance current node to next.
        Advance both l1l1l1 and l2l2l2.
    Return dummy head's next node.

Note that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head's value.

Take extra caution of the following cases:
Test case 	Explanation
l1=[0,1]l1=[0,1]l1=[0,1]
l2=[0,1,2]l2=[0,1,2]l2=[0,1,2] 	When one list is longer than the other.
l1=[]l1=[]l1=[]
l2=[0,1]l2=[0,1]l2=[0,1] 	When one list is null, which means an empty list.
l1=[9,9]l1=[9,9]l1=[9,9]
l2=[1]l2=[1]l2=[1] 	The sum could have an extra carry of one at the end, which is easy to forget.








83. Remove Duplicates from Sorted List
Easy

Given the head of a sorted linked list, delete all duplicates
such that each element appears only once. Return the linked list sorted as well.

Example 1:

Input: head = [1,1,2]
Output: [1,2]

Example 2:

Input: head = [1,1,2,3,3]
Output: [1,2,3]



Constraints:

    The number of nodes in the list is in the range [0, 300].
    -100 <= Node.val <= 100
    The list is guaranteed to be sorted in ascending order.


def deleteDuplicates(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        cur=head
        while cur and cur.next:
            if cur.val==cur.next.val:
                cur.next=cur.next.next
                continue
            cur=cur.next
        return head













Remove Nth Node From End of List
Medium

Given the head of a linked list, remove the nth node from the end of the list and return its head.



Example 1:

Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

Example 2:

Input: head = [1], n = 1
Output: []

Example 3:

Input: head = [1,2], n = 1
Output: [1]



Constraints:

    The number of nodes in the list is sz.
    1 <= sz <= 30
    0 <= Node.val <= 100
    1 <= n <= sz


def removeNthFromEnd(self, head, n):
        temp = head
        c = 0
        while temp:     #Find the length of the linked list
            c+=1
            temp = temp.next
        a = c-n+1       #Calculate the node to be removed
        i = 1
        temp2 = head
        prev = None
        while i < a:         #Traverse till the node to be removed
            i+=1
            prev = temp2     #Prev pointer to point the previous node of the deletion node
            temp2 = temp2.next
        if temp2==head:
            return head.next
        prev.next = temp2.next    #Link the previous node to the next of the deletion node
        return head







141 Linked List Cycle
Easy

Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously
following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to.
Note that pos is not passed as a parameter.

Return true if there is a cycle in the linked list. Otherwise, return false.



Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).

Example 2:

Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.

Example 3:

Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.



Constraints:

    The number of the nodes in the list is in the range [0, 104].
    -105 <= Node.val <= 105
    pos is -1 or a valid index in the linked-list.



Follow up: Can you solve it using O(1) (i.e. constant) memory?




EXPLANATION

    Floyd’s Cycle-Finding Algorithm // fast slow approach // 2 pointers // "tortoise and the hare algorithm"

    Approach: This is the fastest method and has been described below:

    Traverse linked list using two pointers.

    Move one pointer(slow_p) by one and another pointer(fast_p) by two.

    If these pointers meet at the same node then there is a loop. If pointers do not meet then linked list doesn’t have a loop.

image

Above linked list has a loop as node 5 is connected to node 2 foming a Cycle.

CODE WITH EXPLANATION

    Time Complexity : O(N)
    Space Complexity : O(1)

class Solution {
public:
    bool hasCycle(ListNode *head) {

		// if head is NULL then return false;
        if(head == NULL)
            return false;

		// making two pointers fast and slow and assignning them to head
        ListNode *fast = head;
        ListNode *slow = head;

		// till fast and fast-> next not reaches NULL
		// we will increment fast by 2 step and slow by 1 step
        while(fast != NULL && fast ->next != NULL)
        {
            fast = fast->next->next;
            slow = slow->next;


			// At the point if fast and slow are at same address
			// this means linked list has a cycle in it.
            if(fast == slow)
                return true;
        }

		// if traversal reaches to NULL this means no cycle.
        return false;
    }
};



def hasCycle(self, head: Optional[ListNode]) -> bool:
        # s = slow, f = fast
        s,f=head,head
        while f and f.next:
            s=s.next
            f=f.next.next
            if s==f:
                return True
        return False














142. Linked List Cycle II
Medium

Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.

Do not modify the linked list.



Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.

Example 2:

Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.

Example 3:

Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.



Constraints:

    The number of the nodes in the list is in the range [0, 104].
    -105 <= Node.val <= 105
    pos is -1 or a valid index in the linked-list.



Follow up: Can you solve it using O(1) (i.e. constant) memory?


def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        s,f=head,head
        while f and f.next:
            s=s.next
            f=f.next.next
            if s==f:
                s=head
                while s!=f:
                    s=s.next
                    f=f.next
                return s
        return None









148. Sort List
Medium
Given the head of a linked list, return the list after sorting it in ascending order.



Example 1:

Input: head = [4,2,1,3]
Output: [1,2,3,4]

Example 2:

Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]

Example 3:

Input: head = []
Output: []



Constraints:

    The number of nodes in the list is in the range [0, 5 * 104].
    -105 <= Node.val <= 105



def sortList(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if not head:
            return head
        new = []
        curr = head
        while curr:
            new.append(curr.val)
            curr = curr.next

        new.sort()

        curr = head
        index = 0
        while curr:
            curr.val = new[index]
            curr = curr.next
            index += 1

        return head










143. Reorder List
Medium

You are given the head of a singly linked-list. The list can be represented as:

L0 → L1 → … → Ln - 1 → Ln

Reorder the list to be on the following form:

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …

You may not modify the values in the list's nodes. Only nodes themselves may be changed.



Example 1:

Input: head = [1,2,3,4]
Output: [1,4,2,3]

Example 2:

Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]



Constraints:

    The number of nodes in the list is in the range [1, 5 * 104].
    1 <= Node.val <= 1000





def reorderList(self, head):
        """
        :type head: ListNode
        :rtype: None Do not return anything, modify head in-place instead.
        """

        if not head:
            return

        q = deque()
        node = head
        while True:
            node = node.next
            if not node:
                break
            q.append(node)

        while q:
            if head:
                temp = q.pop()
                head.next = temp
                head = head.next

            if head and q:
                temp = q.popleft()
                head.next = temp
                head = head.next

        head.next = None













203. Remove Linked List Elements
Easy

Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.



Example 1:

Input: head = [1,2,6,3,4,5,6], val = 6
Output: [1,2,3,4,5]

Example 2:

Input: head = [], val = 1
Output: []

Example 3:

Input: head = [7,7,7,7], val = 7
Output: []



Constraints:

    The number of nodes in the list is in the range [0, 104].
    1 <= Node.val <= 50
    0 <= val <= 50



intuition

To delete a node, we need to assign the next node to the previous node. Let's use curr to denote the current node, and prev to denote the previous node. Then, we have the following 4 cases:

    Node to remove is at the end of the linked list.

Input: head = [6,1,2,6,3,4,5,6], val = 6
						  /   \
						prev curr

Simple enough, we just need to assign prev.next = None, since curr.next == None. No further action is needed since this is the last node to check.

    Node to remove is in the middle of the linked list.

Input: head = [6,1,2,6,3,4,5,6], val = 6
				  /   \
				prev curr

To remove the node curr, we can assign prev.next = curr.next, which disconnects curr from the linked list completely. In the following iteration, we know that curr = curr.next, while prev should remain pointing at the same node since curr has been removed. So, in summary:

    prev.next = curr.next to remove the node;
    curr = curr.next to get the next iteration.

    Node to remove is at the start of the linked list.

Input: head = [6,1,2,6,3,4,5,6], val = 6
			/   \
	      prev curr

Since prev == None, we don't need to assign prev.next = curr.next. However, removing nodes from the beginning of the linked list changes the head node of the linked list, so we need to assign head = curr.next before proceeding with the next iteration (as per case 2). In summary:

    head = curr.next to change the head node;
    curr = curr.next to get the next iteration.

    Current node is not to be removed.

Input: head = [6,1,2,6,3,4,5,6], val = 6
			    /   \
	          prev curr

Nothing needs to be done, we just need to proceed with the next iteration. This involves:

    curr = curr.next, as discussed in cases 2 and 3;
    prev = curr, since the curr node is not removed in this case.

Implementation

    Start with curr = head and prev = None.
    Loop through the linked list and determine which of the 4 cases curr and prev belong to, and perform the action accordingly.

class Solution:
    def removeElements(self, head, val):
        """
        :type head: ListNode
        :type val: int
        :rtype: ListNode
        """
        prev, curr = None, head
        while curr:
            if curr.val == val:  # cases 1-3
                if prev:  # cases 1-2
                    prev.next = curr.next
                else:  # case 3
                    head = curr.next
                curr = curr.next  # for all cases
            else:  # case 4
                prev, curr = curr, curr.next
        return head

Final Result

TC: O(n) where n is the number of nodes in the linked list.
SC: O(1), no additional data structures were used.















234. Palindrome Linked List
Easy

Given the head of a singly linked list, return true if it is a palindrome.



Example 1:

Input: head = [1,2,2,1]
Output: true

Example 2:

Input: head = [1,2]
Output: false



Constraints:

    The number of nodes in the list is in the range [1, 105].
    0 <= Node.val <= 9


Follow up: Could you do it in O(n) time and O(1) space?




def isPalindrome(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        slow = head
        fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        prev = slow
        slow = slow.next
        prev.next = None
        while slow:
            next_node = slow.next
            slow.next = prev
            prev = slow
            slow = next_node
        while prev:
            if head.val != prev.val:
                return False
            prev = prev.next
            head = head.next
        return True












876. Middle of the Linked List
Easy

Given the head of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.



Example 1:

Input: head = [1,2,3,4,5]
Output: [3,4,5]
Explanation: The middle node of the list is node 3.

Example 2:

Input: head = [1,2,3,4,5,6]
Output: [4,5,6]
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.



Constraints:

    The number of nodes in the list is in the range [1, 100].
    1 <= Node.val <= 100


Intuition and Algorithm

Put every node into an array A in order. Then the middle node is just A[A.length // 2],
since we can retrieve each node by index.

We can initialize the array to be of length 100, as we're told in the problem description
that the input contains between 1 and 100 nodes.


def middleNode(self, head):
    """
    :type head: ListNode
    :rtype: ListNode
    """
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow



















Approach 2: This approach is simpler and uses log n space.

mergeSort():

    If the size of the linked list is 1 then return the head
    Find mid using The Tortoise and The Hare Approach
    Store the next of mid in head2 i.e. the right sub-linked list.
    Now Make the next midpoint null.
    Recursively call mergeSort() on both left and right sub-linked list and store the new head of the left and right linked list.
    Call merge() given the arguments new heads of left and right sub-linked lists and store the final head returned after merging.
    Return the final head of the merged linkedlist.

merge(head1, head2):

    Take a pointer say merged to store the merged list in it and store a dummy node in it.
    Take a pointer temp and assign merge to it.
    If the data of head1 is less than the data of head2, then, store head1 in next of temp & move head1 to the next of head1.
    Else store head2 in next of temp & move head2 to the next of head2.
    Move temp to the next of temp.
    Repeat steps 3, 4 & 5 until head1 is not equal to null and head2 is not equal to null.
    Now add any remaining nodes of the first or the second linked list to the merged linked list.
    Return the next of merged(that will ignore the dummy and return the head of the final merged linked list)







# Node Class
class Node:

    def __init__(self,key):
        self.data=key
        self.next=None

# Function to merge sort
def mergeSort(head):
    if (head.next == None):
        return head

    mid = findMid(head)
    head2 = mid.next
    mid.next = None
    newHead1 = mergeSort(head)
    newHead2 = mergeSort(head2)
    finalHead = merge(newHead1, newHead2)
    return finalHead

# Function to merge two linked lists
def merge(head1,head2):
    merged = Node(-1)

    temp = merged
    # While head1 is not null and head2
    # is not null
    while (head1 != None and head2 != None):
        if (head1.data < head2.data):
            temp.next = head1
            head1 = head1.next
        else:
            temp.next = head2
            head2 = head2.next
        temp = temp.next

    # While head1 is not null
    while (head1 != None):
        temp.next = head1
        head1 = head1.next
        temp = temp.next

    # While head2 is not null
    while (head2 != None):
        temp.next = head2
        head2 = head2.next
        temp = temp.next

    return merged.next

# Find mid using The Tortoise and The Hare approach
def findMid(head):
    slow = head
    fast = head.next
    while (fast != None and fast.next != None):
        slow = slow.next
        fast = fast.next.next
    return slow

# Function to print list
def printList(head):
    while (head != None):
        print(head.data,end=" ")
        head=head.next

# Driver Code
head = Node(7)
temp = head
temp.next = Node(10);
temp = temp.next;
temp.next = Node(5);
temp = temp.next;
temp.next = Node(20);
temp = temp.next;
temp.next = Node(3);
temp = temp.next;
temp.next = Node(2);
temp = temp.next;

# Apply merge Sort
head = mergeSort(head);
print("\nSorted Linked List is: \n");

printList(head);

# This code is contributed by avanitrachhadiya2155

Output:

Sorted Linked List is:
2 3 5 7 10 20

Time Complexity: O(n*log n)

Auxiliary Space: O(n)
























































































































Given a non-empty string like "Code" return a string like "CCoCodCode".


string_splosion('Code') → 'CCoCodCode'
string_splosion('abc') → 'aababc'
string_splosion('ab') → 'aab'




def string_splosion(str):
  res = []
  for i in range(len(str)):
    ch = str[:i + 1]
    res.append(ch)
  return "".join(res)

OR

def string_splosion(str):
  result = ""
  # On each iteration, add the substring of the chars 0..i
  for i in range(len(str)):
    result = result + str[:i+1]
  return result








Find Intersection
Have the function FindIntersection(strArr) read the
array of strings stored in strArr which will c
ontain 2 elements: the first element will represent a list
of comma-separated numbers sorted in ascending order, the second
 element will represent a second list of comma-separated
numbers (also sorted). Your goal is to return a comma-separated
string containing the numbers that occur in elements of strArr in
sorted order. If there is no intersection, return the string false.
Examples
Input: ["1, 3, 4, 7, 13", "1, 2, 4, 13, 15"]
Output: 1,4,13
Input: ["1, 3, 9, 10, 17, 18", "1, 4, 9, 10"]
Output: 1,9,10


def FindIntersection(strArr):

    setOne = set(strArr[0].split(", "))
    setTwo = set(strArr[1].split(", "))

    result = sorted(list(setOne.intersection(setTwo)), key=lambda str: int(str))

    return ','.join(result) if len(result) > 0 else False

# keep this function call here
print(FindIntersection(input()))




Given a string, return the count of the number of times that a substring length 2 appears in the string
 and also as the last 2 chars of the string, so "hixxxhi" yields 1 (we won't count the end substring).


last2('hixxhi') → 1
last2('xaxxaxaxx') → 1
last2('axxxaaxx') → 2



Solution:
def last2(str):
  # Screen out too-short string case.
  if len(str) < 2:
    return 0

  # last 2 chars, can be written as str[-2:]
  last2 = str[len(str)-2:]
  count = 0

  # Check each substring length 2 starting at i
  for i in range(len(str)-2):
    sub = str[i:i+2]
    if sub == last2:
      count = count + 1

  return count









Given an array of ints, return the number of 9's in the array.

Solution:
def array_count9(nums):
  count = 0
  # Standard loop to look at each value
  for num in nums:
    if num == 9:
      count = count + 1

  return count








Given an array of ints, return True if one of the first 4 elements in the array is a 9. The array length may be less than 4.


array_front9([1, 2, 9, 3, 4]) → True
array_front9([1, 2, 3, 4, 9]) → False
array_front9([1, 2, 3, 4, 5]) → False


Solution:
def array_front9(nums):
  # First figure the end for the loop
  end = len(nums)
  if end > 4:
    end = 4

  for i in range(end):  # loop over index [0, 1, 2, 3]
    if nums[i] == 9:
      return True
  return False








Given an array of ints, return True if the sequence of numbers 1, 2, 3 appears in the array somewhere.


array123([1, 1, 2, 3, 1]) → True
array123([1, 1, 2, 4, 1]) → False
array123([1, 1, 2, 1, 2, 3]) → True


Solution:
def array123(nums):
  # Note: iterate with length-2, so can use i+1 and i+2 in the loop
  for i in range(len(nums)-2):
    if nums[i]==1 and nums[i+1]==2 and nums[i+2]==3:
      return True
  return False





Given 2 strings, a and b, return the number of the positions where they
contain the same length 2 substring. So "xxcaazz" and "xxbaaz" yields 3,
since the "xx", "aa", and "az" substrings appear in the same place in both strings.


string_match('xxcaazz', 'xxbaaz') → 3
string_match('abc', 'abc') → 2
string_match('abc', 'axc') → 0


Solution:
def string_match(a, b):
  # Figure which string is shorter.
  shorter = min(len(a), len(b))
  count = 0

  # Loop i over every substring starting spot.
  # Use length-1 here, so can use char str[i+1] in the loop
  for i in range(shorter-1):
    a_sub = a[i:i+2]
    b_sub = b[i:i+2]
    if a_sub == b_sub:
      count = count + 1

  return count










Given a string, return a new string made of every other char starting with the first, so "Hello" yields "Hlo".


string_bits('Hello') → 'Hlo'
string_bits('Hi') → 'H'
string_bits('Heeololeo') → 'Hello'


Solution:
def string_bits(str):
  result = ""
  # Many ways to do this. This uses the standard loop of i on every char,
  # and inside the loop skips the odd index values.
  for i in range(len(str)):
    if i % 2 == 0:
      result = result + str[i]
  return result









Given a string and a non-negative int n, we'll say that the front of the string is the first 3 chars, or whatever is there if the string is less than length 3. Return n copies of the front;


front_times('Chocolate', 2) → 'ChoCho'
front_times('Chocolate', 3) → 'ChoChoCho'
front_times('Abc', 3) → 'AbcAbcAbc'



Solution:
def front_times(str, n):
  front_len = 3
  if front_len > len(str):
    front_len = len(str)
  front = str[:front_len]

  result = ""
  for i in range(n):
    result = result + front
  return result







The parameter weekday is True if it is a weekday, and the parameter vacation is True if we are on vacation. We sleep in if it is not a weekday or we're on vacation. Return True if we sleep in.


sleep_in(False, False) → True
sleep_in(True, False) → False
sleep_in(False, True) → True


Solution:
def sleep_in(weekday, vacation):
  if not weekday or vacation:
    return True
  else:
    return False
  # This can be shortened to: return(not weekday or vacation)



Arrays - DS
EasyProblem Solving (Basic)Max Score: 10Success Rate: 94.19%


Solved
2D Array - DS
EasyProblem Solving (Basic)Max Score: 15Success Rate: 93.18%


Solved
Left Rotation
EasyProblem Solving (Basic)Max Score: 20Success Rate: 90.39%


Solve Challenge
Sparse Arrays
MediumProblem Solving (Basic)Max Score: 25Success Rate: 97.35%


Solve Challenge
Array Manipulation
HardProblem Solving (Intermediate)Max Score: 60Success Rate: 59.11%


Solve Challenge
Print the Elements of a Linked List
EasyProblem Solving (Basic)Max Score: 5Success Rate: 97.30%


Solve Challenge
Insert a Node at the Tail of a Linked List
EasyProblem Solving (Intermediate)Max Score: 5Success Rate: 95.22%


Solve Challenge
Insert a node at the head of a linked list
EasyProblem Solving (Basic)Max Score: 5Success Rate: 98.48%


Solve Challenge
Insert a node at a specific position in a linked list
EasyProblem Solving (Intermediate)Max Score: 5Success Rate: 97.12%


Solve Challenge
Delete a Node
EasyProblem Solving (Basic)Max Score: 5Success Rate: 95.59%


Solve Challenge
Print in Reverse
EasyProblem Solving (Basic)Max Score: 5Success Rate: 98.16%


Solve Challenge
Reverse a linked list
EasyProblem Solving (Intermediate)Max Score: 5Success Rate: 98.07%


Solve Challenge
Compare two linked lists
EasyProblem Solving (Basic)Max Score: 5Success Rate: 98.58%


Solve Challenge
Merge two sorted linked lists
EasyProblem Solving (Intermediate)Max Score: 5Success Rate: 93.89%


Solve Challenge
Get Node Value
EasyProblem Solving (Basic)Max Score: 5Success Rate: 98.44%


Solve Challenge
Delete duplicate-value nodes from a sorted linked list
EasyProblem Solving (Intermediate)Max Score: 5Success Rate: 97.58%


Solve Challenge
Cycle Detection
MediumProblem Solving (Intermediate)Max Score: 5Success Rate: 92.81%


Solve Challenge
Find Merge Point of Two Lists
EasyProblem Solving (Basic)Max Score: 5Success Rate: 92.57%


Solve Challenge
Inserting a Node Into a Sorted Doubly Linked List
EasyProblem Solving (Intermediate)Max Score: 5Success Rate: 92.76%


Solve Challenge
Reverse a doubly linked list
EasyProblem Solving (Intermediate)Max Score: 5Success Rate: 97.26%


Solve Challenge
Tree: Preorder Traversal
EasyProblem Solving (Intermediate)Max Score: 10Success Rate: 98.57%


Solve Challenge
Tree: Postorder Traversal
EasyProblem Solving (Intermediate)Max Score: 10Success Rate: 99.50%


Solve Challenge
Tree: Inorder Traversal
EasyProblem Solving (Advanced)Max Score: 10Success Rate: 99.58%


Solve Challenge
Tree: Height of a Binary Tree
EasyProblem Solving (Advanced)Max Score: 10Success Rate: 96.77%


Solve Challenge
Tree : Top View
EasyProblem Solving (Advanced)Max Score: 20Success Rate: 61.20%


Solve Challenge
Tree: Level Order Traversal
EasyProblem Solving (Advanced)Max Score: 20Success Rate: 96.56%


Solve Challenge
Binary Search Tree : Insertion
EasyProblem Solving (Advanced)Max Score: 20Success Rate: 95.92%


Solve Challenge
Tree: Huffman Decoding
MediumProblem Solving (Intermediate)Max Score: 20Success Rate: 97.93%


Solve Challenge
Binary Search Tree : Lowest Common Ancestor
EasyProblem Solving (Advanced)Max Score: 30Success Rate: 93.20%


Solve Challenge
Swap Nodes [Algo]
MediumProblem Solving (Advanced)Max Score: 40Success Rate: 88.56%


Solve Challenge
Kitty's Calculations on a Tree
AdvancedProblem Solving (Advanced)Max Score: 80Success Rate: 53.31%


Solve Challenge
Is This a Binary Search Tree?
MediumProblem Solving (Advanced)Max Score: 30Success Rate: 75.01%


Solve Challenge
Square-Ten Tree
HardMax Score: 60Success Rate: 76.84%


Solve Challenge
Balanced Forest
HardMax Score: 60Success Rate: 65.50%


Solve Challenge
Jenny's Subtrees
HardMax Score: 70Success Rate: 77.45%


Solve Challenge
Tree Coordinates
ExpertMax Score: 100Success Rate: 63.30%


Solve Challenge
Array Pairs
AdvancedMax Score: 100Success Rate: 8.25%


Solve Challenge
Self Balancing Tree
MediumMax Score: 50Success Rate: 81.51%


Solve Challenge
Array and simple queries
HardMax Score: 80Success Rate: 38.69%


Solve Challenge
Median Updates
HardProblem Solving (Intermediate)Max Score: 70Success Rate: 53.09%


Solve Challenge
Merging Communities
HardProblem Solving (Advanced)Max Score: 50Success Rate: 76.57%


Solve Challenge
QHEAP1
EasyProblem Solving (Intermediate)Max Score: 25Success Rate: 68.24%


Solve Challenge
Maximum Element
EasyProblem Solving (Intermediate)Max Score: 20Success Rate: 71.90%


Solve Challenge
Queue using Two Stacks
MediumProblem Solving (Intermediate)Max Score: 30Success Rate: 89.63%


Solve Challenge
Components in a graph
MediumProblem Solving (Advanced)Max Score: 50Success Rate: 87.86%


Solve Challenge
Balanced Brackets
MediumProblem Solving (Intermediate)Max Score: 25Success Rate: 86.87%


Solve Challenge
Castle on the Grid
MediumProblem Solving (Advanced)Max Score: 30Success Rate: 72.38%


Solve Challenge
Jesse and Cookies
EasyProblem Solving (Intermediate)Max Score: 25Success Rate: 67.90%


Solve Challenge
Kundu and Tree
HardMax Score: 80Success Rate: 83.93%


Solve Challenge
Find the Running Median
HardProblem Solving (Advanced)Max Score: 50Success Rate: 73.84%


Solve Challenge
Down to Zero II
MediumProblem Solving (Intermediate)Max Score: 40Success Rate: 47.10%


Solve Challenge
Equal Stacks
EasyProblem Solving (Intermediate)Max Score: 25Success Rate: 79.92%


Solve Challenge
Minimum Average Waiting Time
HardMax Score: 80Success Rate: 61.40%


Solve Challenge
Truck Tour
HardProblem Solving (Intermediate)Max Score: 50Success Rate: 84.35%


Solve Challenge
Game of Two Stacks
MediumProblem Solving (Intermediate)Max Score: 30Success Rate: 44.40%


Solve Challenge
Largest Rectangle
MediumProblem Solving (Intermediate)Max Score: 50Success Rate: 70.72%


Solve Challenge
Queries with Fixed Length
HardProblem Solving (Intermediate)Max Score: 50Success Rate: 66.44%


Solve Challenge
Super Maximum Cost Queries
HardMax Score: 60Success Rate: 85.62%


Solve Challenge
Simple Text Editor
MediumProblem Solving (Intermediate)Max Score: 65Success Rate: 80.63%


Solve Challenge
Poisonous Plants
HardProblem Solving (Advanced)Max Score: 70Success Rate: 42.13%


Solve Challenge
AND xor OR
HardMax Score: 70Success Rate: 61.18%


Solve Challenge
Waiter
MediumProblem Solving (Intermediate)Max Score: 75Success Rate: 84.03%


Solve Challenge
Contacts
MediumProblem Solving (Advanced)Max Score: 40Success Rate: 67.70%


Solve Challenge
No Prefix Set
HardProblem Solving (Advanced)Max Score: 50Success Rate: 78.12%


Solve Challenge
Data Structures MCQ 1
Multiple Choice QuestionMax Score: 5Success Rate: 72.45%


Solve Challenge
Data Structures MCQ 2
Multiple Choice QuestionMax Score: 5Success Rate: 61.06%


Solve Challenge
Data Structures MCQ 3
Multiple Choice QuestionMax Score: 5Success Rate: 89.52%


Solve Challenge
Kindergarten Adventures
MediumMax Score: 30Success Rate: 50.60%


Solve Challenge
Cube Summation
HardProblem Solving (Advanced)Max Score: 50Success Rate: 67.07%


Solve Challenge
Mr. X and His Shots
MediumMax Score: 50Success Rate: 55.90%


Solve Challenge
Direct Connections
HardMax Score: 60Success Rate: 48.68%


Solve Challenge
Subsequence Weighting
AdvancedMax Score: 60Success Rate: 60.91%


Solve Challenge
Jim and the Skyscrapers
MediumMax Score: 60Success Rate: 60.21%


Solve Challenge
Palindromic Subsets
HardMax Score: 80Success Rate: 74.74%


Solve Challenge
Counting On a Tree
ExpertMax Score: 100Success Rate: 69.01%


Solve Challenge
Polynomial Division
HardMax Score: 60Success Rate: 87.84%


Solve Challenge
Costly Intervals
HardMax Score: 65Success Rate: 85.71%


Solve Challenge
The Strange Function
HardMax Score: 70Success Rate: 73.99%


Solve Challenge
Self-Driving Bus
AdvancedMax Score: 100Success Rate: 75.04%


Solve Challenge
Unique Colors
AdvancedMax Score: 100Success Rate: 83.75%


Solve Challenge
Fibonacci Numbers Tree
ExpertMax Score: 100Success Rate: 79.58%


Solve Challenge
Pair Sums
ExpertMax Score: 80Success Rate: 58.74%


Solve Challenge
Functional Palindromes
AdvancedMax Score: 80Success Rate: 78.39%


Solve Challenge
Lazy White Falcon
HardMax Score: 100Success Rate: 76.90%


Solve Challenge
Ticket to Ride
ExpertMax Score: 100Success Rate: 81.39%


Solve Challenge
Heavy Light White Falcon
HardMax Score: 100Success Rate: 78.88%


Solve Challenge
Sum of the Maximums
AdvancedMax Score: 90Success Rate: 59.29%


Solve Challenge
Number Game on a Tree
ExpertMax Score: 80Success Rate: 86.81%


Solve Challenge
Heavy Light 2 White Falcon
HardMax Score: 100Success Rate: 77.86%


Solve Challenge
Library Query
AdvancedMax Score: 80Success Rate: 74.13%


Solve Challenge
Starfleet
AdvancedMax Score: 100Success Rate: 80.99%


Solve Challenge
Almost Equal - Advanced
ExpertMax Score: 100Success Rate: 49.67%


Solve Challenge
Almost sorted interval
ExpertMax Score: 100Success Rate: 32.07%


Solve Challenge
Burger Happiness
HardMax Score: 100Success Rate: 86.33%


Solve Challenge
Roy and alpha-beta trees
HardMax Score: 120Success Rate: 88.62%


Solve Challenge
Coloring Tree
HardMax Score: 120Success Rate: 72.99%


Solve Challenge
Recalling Early Days GP with Trees
HardMax Score: 120Success Rate: 86.04%


Solve Challenge
Swaps and Sum
AdvancedMax Score: 120Success Rate: 55.16%


Solve Challenge
Arithmetic Progressions
AdvancedMax Score: 80Success Rate: 69.08%


Solve Challenge
Coolguy and Two Subsequences
AdvancedMax Score: 120Success Rate: 73.77%


Solve Challenge
White Falcon And Tree
HardMax Score: 120Success Rate: 88.73%


Solve Challenge
Subtrees And Paths
AdvancedMax Score: 120Success Rate: 81.17%


Solve Challenge
Triplets
AdvancedMax Score: 90Success Rate: 33.96%


Solve Challenge
Beautiful Segments
ExpertMax Score: 120Success Rate: 69.47%


Solve Challenge
Divisibility
ExpertMax Score: 120Success Rate: 56.95%


Solve Challenge
BST maintenance
AdvancedMax Score: 140Success Rate: 60.77%


Solve Challenge
Find Maximum Index Product
MediumMax Score: 100Success Rate: 56.50%


Solve Challenge
Taxicab Driver's Problem
AdvancedMax Score: 150Success Rate: 67.10%


Solve Challenge
Jaggu Playing with Balloons
AdvancedMax Score: 150Success Rate: 75.67%


Solve Challenge
Dynamic Summation
HardMax Score: 150Success Rate: 76.72%


Solve Challenge
Two Array Problem
HardMax Score: 150Success Rate: 75.15%


Solve Challenge
Rooted Tree
HardMax Score: 150Success Rate: 76.45%


Solve Challenge
The crazy helix
AdvancedMax Score: 150Success Rate: 62.91%


Solve Challenge
Network administration
HardMax Score: 150Success Rate: 84.08%


Solve Challenge
Easy Addition
ExpertMax Score: 150Success Rate: 83.48%


Solve Challenge
Find the permutation
ExpertMax Score: 150Success Rate: 80.35%


Solve Challenge
Company Retreat
AdvancedMax Score: 100Success Rate: 83.08%


Solve Challenge
Box Operations
ExpertMax Score: 100Success Rate: 64.02%


Solve Challenge
Max Transform
ExpertMax Score: 100Success Rate: 75.74%


Solve Challenge
Array and Queries
HardMax Score: 60Success Rate: 31.97%

